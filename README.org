#+TITLE: Apparts-Model
#+DATE: [2020-08-06 Thu]
#+AUTHOR: Philipp Uhl

* Usage

You can either work with one, multiple, or no elements. The respective
classes are ~OneModel~, ~ManyModel~, and ~NoneModel~. You can extend
these classes by using them:

#+BEGIN_SRC js
  const { useModel, makeModel } = require("@apparts/model");

  const types = {
    id: {
      /* Types as defined by @apparts/types */
      type: "id",
      /* Will be shown in output of getPublic*/
      public: true,
      /* Auto increment this field */
      auto: true,
      /* This is a key. Combined keys are possible, too, by setting 
         { key: true } on multiple fields. */
      key: true
    }   
    optionalVal: { 
      type: "string", 
      /* This field can be NULL */
      optional: true  
    },
    createdOn: { 
      type: "time", 
      /* This field will be set to the functions result, if the field is
         NULL. The function recieves the element as parameter. */
      default: (c) => c.optionalVal || Date.now() 
    },
    fixedDefault: { 
      type: "int", 
      /* This field will be set to the given value, if the field is
         NULL. */
      default: 7, 
      /* This field will be named "someNumber" in the output of
         getPublic */
      mapped: "someNumber",
      public: true
    },
  };

  const [Users, _User, NoUser] = useModel(types, "users");

  // You can extend the classes like this:
  class User extends _User {
    constructor(dbs, content) {
      super(dbs, content);
      // do something here
    }
    additionalFunc() {
      return this.content;
    }
  }

  module.exports = makeModel("User", [Users, User, NoUser]);
#+END_SRC

The extended classes can then be used:

#+BEGIN_SRC js
  // get dbs from "@apparts/db" somehow
  const peter = await new User(dbs, { optionalVal: "Peter"}).store();
  console.log(peter.content); 
  // => { id: 1, optionalVal: "Peter", createdOn: 12345, fixedDefault: 7 }
#+END_SRC

** ManyModel

_Values:_
- ~contents~ :: Array, that contains the values. The values can be edited. To
  save the changes, call ~update~.

_Functions:_
- ~constructor(dbs, [contents])~ :: Constructor
- ~async load(filter, limit, offset, order)~ :: Load data, filter grammar
  is as defined by the =find= function of the =dbs=. For more information,
  see below at in the section "Filter Grammar".
- ~async loadByIds(ids, limit, offset)~ :: Load data by IDs. For models with
  only one key, you can use ~[<id1>, <id2>, ...]~, for a model with
  multiple keys, you have to use ~{ <key1>: [ <id1>, ...], <key2>:
  [<key2id1>, ...], ...}~.
- ~async store()~ :: Saves to the database
- ~async update()~ :: Updates the values, if you updated the contents.
- ~length()~ :: Length of ~contents~
- ~set(field, val)~ :: Set a field on all elements
- ~setF(field, f)~ :: Set a field on all elements through a function,
  that receives the element and returns the new value
- ~async deleteAll()~ :: Delete all from the loaded collection from the
  database. If any of the items is referenced by another item,
  =IsReference= will be thrown.
- ~getPublic()~ :: Get the public representation (marked as public in
  the types definition by the key ~public (bool)~).

** OneModel

_Values:_
- ~content~ :: Object, that contains the values. The values can be edited. To
  save the changes, call ~update~.

_Functions:_
- ~constructor(dbs, [content])~ :: Constructor
- ~async load(filter)~ :: Load one item. If more than one item was found
  that satisfies the filter, a =NotUnique= error will be thrown. The filter grammar
  is as defined by the =find= function of the =dbs=. For more information,
  see below at in the section "Filter Grammar".
- ~async loadById(id)~ :: Load data by ID. For models with
  only one key, you can use ~<id>~, for a model with
  multiple keys, you have to use ~{ <key1>: <id>, <key2>: <key2id>, ... }~.
- ~async store()~ :: Saves to the database
- ~async update()~ :: Updates the values, if you updated the contents.
- ~set(field, val)~ :: Set a field on all elements
- ~async delete()~ :: Delete this element from the database. If the item
  is referenced by another item, =IsReference= will be thrown.
- ~getPublic()~ :: Get the public representation (marked as public in
  the types definition by the key ~public (bool)~).

** NoneModel

_Functions:_
- ~constructor(dbs)~ :: Constructor
- ~async loadNone(filter)~ :: Throws an ~DoesExist~ error, if something was
  loaded, does nothing if nothing was loaded. The filter grammar
  is as defined by the =find= function of the =dbs=. For more information,
  see below at in the section "Filter Grammar".

** Errors

- ~DoesExist~
- ~NotFound~
- ~NotUnique~
- IsReference

#+BEGIN_SRC js
  const { NotUnique, NotFound, DoesExist, IsReference } = require("@apparts/model");
#+END_SRC

** Filter Grammar

The filter syntax is like this:

#+BEGIN_SRC js
const filter = { <key>: <matcher>, ...};
// where <key> is a key from the type and
// where matcher is
<matcher> = <value>
        | { op: <numoperator>, val: <int> }
        | { op: <stroperator>, val: <string> }
        | { op: "and", val: <matcher> } // logical and for all subconditions
<numoperator> = lte  // less than or equals
              | lt   // less than
              | gte  // greater than or equals
              | gt   // greater than
<stroperator> = like // sql like, a string comparison where the "%" character
                     // will be matched against anything. E.g. "bread%crumb"
                     // matches "bread crumb" or "bread eating crumb".
<value> = <string>
        | <int>
        | <boolean>
        | null
#+END_SRC
